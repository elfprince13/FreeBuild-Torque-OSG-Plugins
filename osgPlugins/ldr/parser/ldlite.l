%{
	
	/*
	 * Lex syntax for LDRAW command files.
	 *
	 * You must manually add #include <stdlib.h> to beginning of 
	 * lex.yy.c (right after the #include <stdio.h>), which is
	 * produced from this file via flex.  Otherwise, routines using
	 * atof() will get garbage numbers.
	 *
	 * Used with express permission of Paul Gyugyi under the following terms:
	 *		I hearby grant you an unrestricted license to do whatever you like with the code,
	 *		specifically to include it in a closed source application and/or modify it as
	 *		you see fit.
	 *
	 */
	
	/* This C file is generated by the
	 *	 program flex from ldlite.l. At the end are some important
	 *	 routines for handling include files. The code is mostly taken
	 *	 from the flex man page, in the section describing how to do
	 *	 include files. If you regenerate this file using lex, you will
	 *	 need to make two edits. Make sure stdlib.h is included right
	 *	 after stdio.h at the beginning of lex.yy.c. Also, change the
	 *	 definition of automatically created yylex() to be called
	 *	 my_yylex(). At the end of the file is a funtion called yylex()
	 *	 which is faster than the standard one, since it caches previous
	 *	 token streams. The code makes use of some flex-specific features,
	 *	 so a standard lex program won't work.
	 */
	
#include <stdio.h>
#include "ldraw.h"
	
	using namespace LDParse;
	
#define YY_NEVER_INTERACTIVE 1
	YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
	
	
#if defined( _DEBUG    ) || defined( DEBUG )
#define FLEX_DEBUG 1
#else
#define FLEX_DEBUG 0
#endif
#define YY_NO_UNISTD_H
	
	// Hack to make windows lex happy.
#ifndef isatty
	inline int isatty(int) { return 0; }
#endif
	
%}

%option noyywrap
%option yylineno

alpha	[a-zA-Z]
special	[\.\_,\-\~/\\#:()\[\]]
hexprefix 0x
digit	[0-9]
hexdigit [0-9a-fA-F]
sign	[\+\-]
exp	[Ee]{sign}?{digit}+
ident	({alpha}|{digit}|{special})+

%x STRING

%%
["]         { BEGIN(STRING); }
 [ \t\r]		;
 [\n]		{yylval.c = "EOL"; return tEOL;}
 5			{yylval.i = atoi(yytext); return tFIVE;}
 4			{yylval.i = atoi(yytext); return tFOUR;}
 3			{yylval.i = atoi(yytext); return tTHREE;}
 2			{yylval.i = atoi(yytext); return tTWO;}
 1			{yylval.i = atoi(yytext); return tONE;}
 0			{yylval.i = atoi(yytext); return tZERO;}
 STEP		{yylval.c = "STEP"; return tSTEP;}
 PAUSE		{yylval.c = "PAUSE"; return tPAUSE;}
 WRITE		{yylval.c = "WRITE"; return tWRITE;}
 PRINT		{yylval.c = "PRINT"; return tWRITE;}
 CLEAR		{yylval.c = "CLEAR"; return tCLEAR;}
 SAVE		{yylval.c = "SAVE"; return tSAVE;}
 ROTATE      {yylval.c = "ROTATE"; return tROTATE;}
 TRANSLATE   {yylval.c = "TRANSLATE"; return tTRANSLATE;}
 SCALE       {yylval.c = "SCALE"; return tSCALE;}
 TRANSFORM   {yylval.c = "TRANSFORM"; return tTRANSFORM;}
 COLO[U]?R   {yylval.c = "COLOR"; return tCOLOR;}
 COLO[U]?RNAME   {yylval.c = "COLORNAME"; return tALIAS;}
 POINT       {yylval.c = "POINT"; return tPOINT;}  
 MATRIX      {yylval.c = "MATRIX"; return tMATRIX;}
 FILE		{yylval.c = "FILE"; return tFILE;}
 END         {yylval.c = "END"; return tEND;}
 
 
 <STRING>[^"\n]* { 
	/* eat the string */
	yylval.c = dStrdup(yytext); return tIDENT;
}

<STRING>["\n] { BEGIN(INITIAL); }
		 
		 {hexprefix}{hexdigit}+		{
		 S32 a;
		 a = 0;
		 sscanf(yytext,"%i",&a);
		 yylval.i = a; 
		 return tINT;
		 }
		 
		 {sign}?{digit}+		{
		 S32 a;
		 a = 0;
		 a = atoi(yytext);
		 yylval.i = a; 
		 return tINT;
		 }
		 
		 {sign}?{digit}+"."{digit}*({exp})? |
		 {sign}?{digit}*"."{digit}+({exp})? |
		 {sign}?{digit}+{exp}		{
		 yylval.d = atof(yytext);
		 return tFLOAT;
		 }
		 {ident}		{yylval.c = dStrdup(yytext); return tIDENT;}
		 
		 [^ \t\r\n"]+	{yylval.c = dStrdup(yytext); return tGARBAGE;}


<<EOF>> {
	yylval.c = "EOF";
	return tEOF;
}

%%


S32 LDParse::start_include_file(char *root_name)
{
	//static char filename[256];
	//char fixed_root_name[256];
	
	
	char * fbuf = NULL;
	
	S32 ftype=0;
	CACHED_STREAM *found_it;
	
	AssertFatal(include_stack_ptr < (MAX_INCLUDE_DEPTH-1), "Includes nested too deeply" );
	// look up to see if file is in cache.
	{
		S32 i;
		
		found_it = NULL;
		for(i=0; i<cached_file_stack_index; i++) {
			switch (cached_streams[i].valid) {
				case CHS_UNUSED:
					break;
				case CHS_PROBLEM:
				case CHS_FILLING:
				case CHS_FILLED:
					if(!osgDB::equalCaseInsensitive(root_name,cached_streams[i].filename)) {
						found_it = &(cached_streams[i]);
					}
					break;
			}
		}		  
	}
	
	if ((found_it) && (found_it->valid == CHS_FILLED)) {
		// we can replay the cached file
		include_stack_ptr++;
		cached_file_stack[include_stack_ptr] = found_it;
		found_it->next_token_index = 0;
		//current_type[include_stack_ptr] = found_it->ftype;
		return 0;
	} else {
		// read it from the file system
		fbuf = LDParse::bufferFile(LDParse::findLDrawFile(root_name));
		if(fbuf) {
			include_stack_ptr++;
			
			//fp_stack[include_stack_ptr] = fp;
			include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
			//yyin = fp;
			//yy_switch_to_buffer(yy_create_buffer( yyin, YY_BUF_SIZE ) );
			/*yy_switch_to_buffer(*/yy_scan_buffer(fbuf, strlen(fbuf) + 2)/*)*/;
			//current_type[include_stack_ptr] = ftype;
			// if entry in cache is not marked bad, cache this file
			if (((ftype == TYPE_P) || (ftype == TYPE_PART))
				&& (found_it == NULL)) {
				CACHED_STREAM *chs = NULL;
				
				// find an unused place to store this cached file
				if (cached_file_stack_index < MAX_CACHED_FILES) {
					chs = &(cached_streams[cached_file_stack_index]);
					chs->valid = CHS_FILLING;
					strcpy(chs->filename, root_name);
					chs->ftype = ftype;
					chs->next_token_index = 0;
					// malloc here
					chs->tokens.resize(MAX_CACHED_TOKENS);
					if (chs->tokens.size() != MAX_CACHED_TOKENS) {
					    chs->valid = CHS_PROBLEM;
					} else {
					    chs->values.resize(MAX_CACHED_TOKENS);
						if (chs->values.size() != MAX_CACHED_TOKENS) {
							chs->tokens.clear();
							chs->valid = CHS_PROBLEM;
						} else {
							cached_file_stack_index++;
							chs->max_tokens = MAX_CACHED_TOKENS;
						}
					}
				}
				// save name and type
				// set entry in stack so yylex stores the tokens
				cached_file_stack[include_stack_ptr] = chs;
#if defined( _DEBUG    ) || defined( DEBUG )
				if (chs != NULL) {
					std::cout << "Caching file "<< root_name <<" in slot " << (cached_file_stack_index-1) << std::endl;
				} else {
					std::cout << "No room to cache file " << root_name << std::endl;
				}
#endif
			} else {
				// do not cache this file
				cached_file_stack[include_stack_ptr] = NULL;
			}
			return 0;
		} else {
			return -1;
		}
	}
}

S32 LDParse::defer_stop_include_file(void)
{
	static S32 init=0;
	S32 i;
	if(!init) {
		init = 1;
		for(i=0; i<MAX_INCLUDE_DEPTH; i++) {
			deferred_flag[i] = 0;
		}
	}
	deferred_flag[include_stack_ptr-1] = 1;
	return 0;
}

S32 LDParse::stop_include_file(void)
{
	if ( include_stack_ptr > 0 ) {	
		if ((cached_file_stack[include_stack_ptr] != NULL) &&
			(cached_file_stack[include_stack_ptr]->valid == CHS_FILLED)) {
			// we were working from cache, so do not close or delete any yy_stuff
			cached_file_stack[include_stack_ptr] = NULL;
			ldlite_profile.cache_hits++;
		} else {
			if ((cached_file_stack[include_stack_ptr] != NULL) &&
				(cached_file_stack[include_stack_ptr]->valid == CHS_FILLING)) {
				cached_file_stack[include_stack_ptr]->valid = CHS_FILLED;
				ldlite_profile.cached_files++;
#if defined( _DEBUG    ) || defined( DEBUG )
				std::cout << "Cached " << cached_file_stack[include_stack_ptr]->filename <<", used "<<cached_file_stack[include_stack_ptr]->next_token_index) <<" tokens" << std::endl;
				
#endif
			} else {
				ldlite_profile.uncached_files++;
			}
			cached_file_stack[include_stack_ptr] = NULL;
			yy_delete_buffer( YY_CURRENT_BUFFER );
			yy_switch_to_buffer( include_stack[include_stack_ptr] );
			//fclose(fp_stack[include_stack_ptr]);
		}
		/* free transform matrix and translation vector */
		pop_transform();
		/* free zcolor table */
		znamelist_pop();
		
		deferred_flag[include_stack_ptr] = 0;
		/*if (current_type[include_stack_ptr] >= zDetailLevel) {
		 zStep(-1,0);
		 }*/
		include_stack_ptr--;
		if (deferred_flag[include_stack_ptr] != 0) {
			return stop_include_file();
		} else {
			return include_stack_ptr;
		}
	} else {
		/* free transform matrix and translation vector */
		pop_transform();
		/* free zcolor table */
		znamelist_pop();
		//	  yy_delete_buffer( YY_CURRENT_BUFFER );
#if defined( _DEBUG    ) || defined( DEBUG )
		std::cout	<< "Profile: " << ldlite_profile.cached_files
		<< " cached, " << ldlite_profile.uncached_files
		<< " uncached, " << ldlite_profile.cache_hits
		<< " hits" << std::endl;
#endif
		return (-1);
	}
}

void stop_caching()
{
	
	if (cached_file_stack[include_stack_ptr] != NULL) {
		if (cached_file_stack[include_stack_ptr]->valid == CHS_FILLING) {
			cached_file_stack[include_stack_ptr]->valid = CHS_PROBLEM;
		}
	}
	return;
}

S32 is_current_file_not_cached()
{
	
	if (cached_file_stack[include_stack_ptr] == NULL) {
		return 1;
	} else {
		if (cached_file_stack[include_stack_ptr]->valid == CHS_PROBLEM) {
			return 1;
		} else {
			return 0;
		}
	}
}

// TBD: This function probably has memory leaks.
S32 LDParse::cache_mpd_subfiles(char *mpd_subfile_name)
{
	// keep stack space light, because this is a recursive function,
	// called for each 0 FILE line in the file.
	CACHED_STREAM *chs = NULL;
	S32 rc;
	S32 state;
	
	// if this file is already cached, return
	// look up to see if file is in cache.
	{
		S32 i;
		
#if defined( _DEBUG    ) || defined( DEBUG )
		std::cout << "caching MPD file " << mpd_subfile_name << std::endl << std::endl;
#endif
		
		for(i=0; i<cached_file_stack_index; i++) {
			switch (cached_streams[i].valid) {
				case CHS_UNUSED:
					break;
				case CHS_PROBLEM:
				case CHS_FILLING:
					if(osgDB::equalCaseInsensitive(mpd_subfile_name,cached_streams[i].filename)) {
						return(-1);
					}
					break;
				case CHS_FILLED:
					if(osgDB::equalCaseInsensitive(mpd_subfile_name,cached_streams[i].filename)) {
						return(0);
					}
					break;
			}
		}		  
	}
	
	// find an unused place to store this cached file
	if (cached_file_stack_index >= MAX_CACHED_FILES) {
#if defined( _DEBUG    ) || defined( DEBUG )
		std::cout << "Not caching MPD subfile "<<mpd_subfile_name<<", too many files already cached."<<std::endl;
#endif
		return(-1);
	}
	chs = &(cached_streams[cached_file_stack_index]);
	chs->valid = CHS_FILLING;
	strcpy(chs->filename, mpd_subfile_name);
	chs->ftype = TYPE_PART;  // treat it like a part for purposes of screen updates
	chs->next_token_index = 0;
	// malloc here
	//chs->tokens =  (S32 *)dMalloc(MAX_CACHED_TOKENS*sizeof(S32));
	chs->tokens.resize(MAX_CACHED_TOKENS);
	if (chs->tokens.size() != MAX_CACHED_TOKENS) {
#if defined( _DEBUG    ) || defined( DEBUG )
		std::cerr << "Not caching MPD subfile "<<mpd_subfile_name<< ", out of memory (1)."<<std::endl;
#endif
		return (-1);
	}
	//chs->values = (YYSTYPE *)dMalloc(MAX_CACHED_TOKENS*sizeof(YYSTYPE));
	chs->values.resize(MAX_CACHED_TOKENS);
	if (chs->values.size() != MAX_CACHED_TOKENS) {
		//dFree(chs->tokens);
		chs->tokens.clear();
#if defined( _DEBUG    ) || defined( DEBUG )
		std::cerr << "Not caching MPD subfile "<<mpd_subfile_name<<", out of memory (2)."<<std::endl;
#endif
		return (-1);
	}
	chs->max_tokens = MAX_CACHED_TOKENS;
	cached_file_stack_index++;
	
#if defined( _DEBUG    ) || defined( DEBUG )
	std::cout << "Caching MPD subfile " << mpd_subfile_name<<std::endl;
#endif
	state = 0;
	while (1) {
		rc = my_yylex();
		if (rc == tEOF) {
			chs->tokens[chs->next_token_index] = rc;
			chs->values[chs->next_token_index] = yylval;
			chs->next_token_index++;
			if (chs->valid == CHS_FILLING) {
				chs->valid = CHS_FILLED;
#if defined( _DEBUG    ) || defined( DEBUG )
				std::cout << "Cached " << chs->filename << ", used "<<chs->next_token_index<<" tokens"<<std::endl;
#endif
			}
			return(0);
		} else {
			if (chs->next_token_index >= (chs->max_tokens-1)) {  /* leave room for EOF */
#if 0
				/* TBD: realloc */
				stop_caching();
#if defined( _DEBUG    ) || defined( DEBUG )
				std::cout << "MPD subfile " << chs->filename <<" is too large to cache"<<std::endl;
#endif
#else
				//chs->tokens = (S32 *)dRealloc(chs->tokens, 2*chs->max_tokens*sizeof(S32));
				//chs->values = (YYSTYPE *)dRealloc(chs->values, 2*chs->max_tokens*sizeof(YYSTYPE));
				chs->tokens.resize(chs->max_tokens * 2);
				chs->values.resize(chs->max_tokens * 2);
				chs->max_tokens = 2*chs->max_tokens;
				if ((chs->tokens.size() != chs->max_tokens) || (chs->values.size() != chs->max_tokens))
				{
					stop_caching();
#if defined( _DEBUG    ) || defined( DEBUG )
					std::cerr << "MPD subfile %s is too large to cache " << chs->filename << std::endl;
#endif
				} else {
#if defined( _DEBUG    ) || defined( DEBUG )
					std::cout << "MPD subfile "<< chs->filename << " is large, increasing cache to "
					<<chs->max_tokens << " tokens"<<std::endl;
#endif
				}
				
#endif
			} else {
				chs->tokens[chs->next_token_index] = rc;
				chs->values[chs->next_token_index] = yylval;
				chs->next_token_index++;
			}
			switch (state) {
				case 0:
					if (rc == tZERO) {
						state = 1;
					}
					break;
				case 1:
					if (rc == tFILE) {
						state = 2;
					} else {
						state = 0;
					}
					break;
				case 2:
					if (rc = tIDENT) {
						if (chs->valid == CHS_FILLING) {
							// remove "0 FILE name" from this stream...
							chs->next_token_index -= 3;
							// and insert an EOF character
							chs->tokens[chs->next_token_index] = tEOF;
							chs->values[chs->next_token_index].c  = "EOF";
							chs->next_token_index++;
							//
							chs->valid = CHS_FILLED;
#if defined( _DEBUG    ) || defined( DEBUG )
							std::cout << "Cached "<<chs->filename<<", used "<<chs->next_token_index<<" tokens"<<std::endl;
#endif
						}
						return cache_mpd_subfiles(yylval.c);
					} else {
						state = 0;
					}
					break;
			}
#if 0 /* not needed ? */
			if (chs->next_token_index >= chs->max_tokens) {
				/* TBD: realloc */
				stop_caching();
#if defined( _DEBUG    ) || defined( DEBUG )
				std::cerr << "MPD subfile %s is too large to cache " << chs->filename << std::endl;
#endif
			}
#endif
		}
	}
}

S32 LDParse::yylex(void)
{
	static S32 init=0;
	S32 rc;
	
	if(!init) {
		S32 i;
		
		init=1;
		include_stack_ptr = 0;
		for (i=0; i<MAX_INCLUDE_DEPTH; i++) {
			cached_file_stack[i] = NULL;
		}
		for (i=0; i<MAX_CACHED_FILES; i++) {
			cached_streams[i].valid = CHS_UNUSED;
		}
		ldlite_profile.cached_files=0;
		ldlite_profile.uncached_files=0;
		ldlite_profile.cache_hits=0;
	}
	
	if (cached_file_stack[include_stack_ptr] == NULL) {
		// top level .dat file (or caching disabled), do not cache
		return my_yylex();
	} else {
		CACHED_STREAM *chs;
		// we are inside an included file.  Either it is being cached or has already been cached
		chs = cached_file_stack[include_stack_ptr];
		switch(chs->valid) {
			case CHS_UNUSED:
			case CHS_PROBLEM:
				// error condition?
				return my_yylex();
				break;
			case CHS_FILLING:
				rc = my_yylex();
				chs->tokens[chs->next_token_index] = rc;
				chs->values[chs->next_token_index] = yylval;
				chs->next_token_index++;
				if (chs->next_token_index >= chs->max_tokens) {
					/* TBD: realloc */
					stop_caching();
#if defined( _DEBUG    ) || defined( DEBUG )
					std::cerr << "File %s is too large to cache " << chs->filename << std::endl;
#endif
				}
				return rc;
				break;
			case CHS_FILLED:
				rc = chs->tokens[chs->next_token_index];
				yylval = chs->values[chs->next_token_index];
				chs->next_token_index++;
				return rc;
				break;
		}
	}
}

S32 LDParse::initParse(const char* filename){
	
	
	zcolor_init();
	transform_stack_ptr = 0;
	include_stack_ptr = 0;
	current_transform[transform_stack_ptr] = savemat(0.0,0.0,0.0, 1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0);
	
	
	char * fbuf = LDParse::bufferFile(LDParse::findLDrawFile(filename));
	if(fbuf) {
		
		YY_BUFFER_STATE mbs = yy_scan_buffer(fbuf, strlen(fbuf) + 2);
		S32 my_parse_result  = LDyyparse ();
		yy_delete_buffer (mbs);
		return my_parse_result;
		
	}
	return -1;
}
